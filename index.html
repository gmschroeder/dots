<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>mobileDots</title>
</head>
<body>
  <script src="node_modules/p5/lib/p5.min.js"></script>
  <script src="node_modules/p5/lib/addons/p5.sound.js"></script>
  <script src="js/p5.collide2D/p5.collide2d.min.js"></script>
  <script> 
      

      var dots;
      var canvasColor;
      
      function setup() {
          canvasColor = 0;
          dots = [];
          var canvasSize = {
              'width': innerWidth,
              'height': innerHeight
          };
          
          
          
          createCanvas(canvasSize['width'], canvasSize['height']);
          background(canvasColor);                        
          noStroke();
          

      }
      

  // Patch the input to an volume analyzer
  
      
      
      function draw() {
          background(128)
          var amplitudeSum;
          
          for (var i=0; i<= dots.length - 1; i++) {
              dots[i].detectEdgeCollision();
              dots[i].detectDotCollision(dots);
              this.
              dots[i].move();
              dots[i].display();
            }
      }
            
      function Dot() {
          this.x = mouseX;
          this.y = mouseY;
          this.diameter = 50;
          this.speed = {
              'x': 20,
              'y': 20
          };
          
          // amplitude measuring
          this.analyzer = new p5.Amplitude();
          this.analyzer.setInput(this.osc);
          //this.rms = this.analyzer.getLevel();
          this.rms = 0;
          
          this.color = random(255);
          // root third fourth fifth seventh
          this.scaleArray = [60, 64, 65, 67, 71, 72];
          this.note = 0;
          

          
          this.osc = new p5.SinOsc();
          
          // Instantiate the envelope
          this.envelope = new p5.Env();
          
          // set attackTime, decayTime, sustainRatio, releaseTime
          this.envelope.setADSR(0.001, 0.5, 0.1, 0.5);
          
          // set attackLevel, releaseLevel
          this.envelope.setRange(1, 0);
          this.osc.start();
          
          this.pluck = function() {
              this.note = Math.floor(random(this.scaleArray.length));
              console.log(this.note);
              this.midiValue = this.scaleArray[this.note];
              this.freqValue = midiToFreq(this.midiValue);
              this.osc.freq(this.freqValue);
              this.envelope.play(this.osc, 0, 0.1);
              this.rms = this.analyzer.getLevel();
          }
          
          this.move = function() {
              this.x += this.speed['x'];
              this.y += this.speed['y'];
          };          
          this.display = function() {
              fill(this.color);
              ellipse(this.x, this.y, this.diameter, this.diameter);
          }

          // determine if another dot is touching this one
          this.detectDotCollision = function(dotArray){
              // cycle through array of dots
              for(var i=0; i < dotArray.length; i++) {
                  
                  // skip itself
                  if(dotArray[i] !== this){
                      
                      //colliding with anything?
                      this.hit = collideCircleCircle(
                          this.x, this.y, this.diameter, dotArray[i].x, dotArray[i].y, dotArray[i].diameter
                      ); 
                      
                      if(this.hit === true){
                          dotArray[i]['x'].speed = -1 * dotArray[i].speed['x'];
                          dotArray[i]['y'].speed = -1 * dotArray[i]['x'].speed;
                          this.speed['x'] = -1 * this.speed['x'];
                          this.speed['y'] = -1 * this.speed['y'];
                          // cludge to prevent dots from getting 'stuck' together
                          this.x += this.diameter + 5;
                          this.y += this.diameter + 5;
                          
                          /*this.x = random(innerWidth - this.diameter);
                          this.y = random(innerHeight - this.diameter);*/
					}
                  }
              }
          }
          
          this.detectEdgeCollision = function() {
              // horizontal edge detection
              if (this.x + this.diameter > innerWidth) {
                  this.speed['x'] = this.speed['x'] * -1;
                  this.x -= this.diameter - 5;
                  this.pluck();
              } 
              if (this.x - this.diameter < 0) {
                  this.speed['x'] = this.speed['x'] * -1;
                  this.x += this.diameter + 5;
                  this.pluck();
              };
              
              // vertical edge detection
              if (this.y + this.diameter > innerHeight) {
                  this.speed['y'] = this.speed['y'] * -1;
                  this.y -= this.diameter - 5;
                  this.pluck();
              } 
              if (this.y - this.diameter < 0) {
                  this.speed['y'] = this.speed['y'] * -1;
                  this.y += this.diameter + 5;
                  this.pluck();

              };
          };
      }
      
      function mousePressed() {
          dots.push(new Dot());        
      };
  
  </script>
</body>
</html>
